
	1）―――――SpringAOP相关知识点―――――

	Spring可以拦截到继承自Action类的方法，而拦截不到继承自DispatchAction类中的方法，
	这可以说是Spring的bug，从底层分析这就是动态代理技术的一个问题。
	――分析原因：	【Spring不能对通过反射技术调用的方法应用通知】
	【具体解析】
	public class A extends DispatchAction{
		void method1(){}
		void method2(){}
	}
	【生成代理对象的过程】
		当我们定义了切入点表达式execution的时候，发现所拦截到的类符合该表达式语言，Spring会为当前拦截到的类生
		成一个代理对象，由于当前类A没有借口，所以Spring会默认使用cglib技术来为该类生成一个代理对象！
		――代理对象源码(原理的伪代码):
			【根据cglib生成代理对象的特点：cglib是通过继承目标类A，并且重写所有非final的方法来实现代理】
			public class AAAAA {
				private Object target;	//【目标对象――指得就是原始Action的类对象】
				/*【因为代理对象的类继承A，A继承DispatchAction，DispatchAction继承Action】
				所以当其复写所有非final方法的同时，也会复写Action类中的execute()方法】*/
				void execute(){
					target.execute();	//【调用目标对象中的execute()方法】
				}		
				void method1(){
					@Around("actionMethod()")
					public Object interceptor(ProceedingJoinPoint pjp) throws Throwable{
						System.out.println("拦截到了："+pjp.getSignature().getName()+"方法");
						return pjp.proceed(){
							//【内部实际上执行目标对象对应的方法】
							return target.method1();
						};
					}
				}
				void method2(){}
			}
			注意：【Spring只会为定义在本类当中的方法应用通知】
		――	1.而当前代理对象中的execute()方法并不属于在类A中定义的方法，而是在其父类
				Action中定义的execute()方法，所以Spring不会为该execute()方法应用通知。
				而是内部通过使用调用目标对象的方法。
		――	2.而对于method1()和method2()方法而言，则会应用上通知，因为该方法是属于A。
	
	【请求处理的过程】――>可见：拦截请求过程.png
		第一步：请求到达Struts框架，Struts框架向Spring容器要Action(已经交给Spring托管)。
		第二步：Spring容器首先会为该Action生成一个代理对象	，于是Struts框架会再去请求这个代理对象。
		第三步：然而，根据应用场景这个代理对象内部需要复写父级的execute()方法，所以就会首先执行该execute()方法。
		第四步：然而代理对象中的execute()方法内部则是调用目标对象中的execute()方法，而该场景的目标对象没有execute()方法，
					那就执行其父类DispatchAction中的execute()方法，该方法内部是通过复写它的父类Action中的execute()方法，
					该方法的原理比较复杂：首先取得请求参数的名称，再取得方法名称，最后通过method.invoke(this,args);反射来完成
					目标对象方法的调用【this指的是目标对象，而不是代理对象】，所以method.invoke(this,args);调用的是目标对象中
					的相关方法，而没有经过代理对象，那么【Spring只会为定义在本类当中的方法应用通知】，所以代理对象中的目标对象方
					法就不回应用上通知了。
		根本原因：就是method.invoke(this,args);中的this要指向代理对象，而不能指向目标对象！那反射的方法就会是代理对象中的方法了。
	
		【解决方案】――Spring提供了一个类库，专门得到代理对象，然后将其传进去即可！――这样代码的入侵性就太强，不采用！
				――>【自定义AOP技术实现对action方法进行拦截并实现权限拦截,采用自定义标签控制页面功能按钮的显示】
				――>见下边的：”自定义AOP技术“部分！

	2）――――【Spring执行过程，生成代理对象技术】――――
	
	――>需求：	
		我们要对业务bean里面所有的方法进行拦截，拦截到这个方法之后，我们判断用户是否为null
		如果用户为null，那它就没有权限调用该业务方法，如果不为null，那么就代表它有权限调用该
		业务方法。
	――>步骤：	
		第一步：拦截所有的业务方法。
		第二步：判断用户是否有权限，有权限就允许它执行业务方法，没权限，就不允许其执行。
				  (是否有权限是根据用户user是否为null作为判断依据来模拟的)
	
	【细节阐述1】
	由于action是交给Spring来管理的，所以当Struts框架接受到用户的请求之后，Struts框架首先会向Spring容器拿到
	对应的action对象――这里得到的action是原始Action的代理对象！！！
	在action的代理对象里面，也有自己的execute()方法，在该代理对象的execute()方法内部可以应用上通知！！！
	如果遇到环绕通知，内部就必须调用proceed()方法，而该方法就会调用目标对象的execute()方法，即就是各种操作……
	
	【细节阐述2】
		客户端应用――――>代理对象――――>目标对象(业务bean)
	客户端应用在调用实际的目标对象(业务bean)之前，要先经过代理对象，即就是客户端调用
	的是代理对象。这个代理对象实现了目标对象的所有接口。所以通过代理对象的调用可以把方
	法的调用委派给目标对象。等同于（在代理对象的方法内部调用了目标对象的方法）！
	这样一来，就不需要在目标对象里面编写臃肿的控制代码来做权限的判断和拦截了。只需要在
	处理代理对象里面，在执行目标对象方法之前，对权限做一个判断，有权限则调用目标对象里
	面的方法；无权限，则不能调用其方法。那么如何创建代理对象呢？
	
	【创建代理对象】
		――>两种方式（默认是采用cglib技术来生成代理对象）
					a).实现接口：通过JDK提供的Proxy类去创建代理对象
					b).未实现接口：通过cglib去创建代理对象
		1.	静态代理(很少使用)
		2.	动态代理
			我们不需要再去为目标对象去编写静态代理类了，只需要通过JDK或者第三方框架来动态
			生成代理对象的字节码就可以了。
			【注意】JDK提供的代理类Proxy，是专门为目标对象动态创建代理对象的、
			【Proxy使用的前提】
			目标对象必须要实现接口，也就是说目标对象必须要面向接口的时候，我们才可以使用JDK
			提供的代理类Proxy来创建代理对象。如果目标对象没有实现接口，我们就不能使用Proxy。
			
	【cglib方式】创建目标对象的代理对象
			在实际应用中，我们的情况可能比较复杂，有可能类没有实现接口，那么就不能用JDK提供的
			Proxy来创建代理对象(Proxy有使用的前提：必须实现接口)，那么我们又该如何做呢？
			这时候我们就用到了第三方创建代理对象的框架cglib(必须导入cglib的jar文件)来创建目标
			对象的代理对象，cglib不要求目标对象必须实现接口。
			假设目标对象没有实现任何接口，我们使用cglib来创建目标对象的代理对象
			(1.引入jar文件 2.创建cglib的代理工厂来创建目标对象的代理对象)
	
	
	
	3）.【自定义AOP技术部分】
			自定义AOP技术实现对action方法进行拦截并实现权限拦截,采用自定义标签控制页面功能按钮的显示
			【使用原因】――Spring不能对通过反射技术调用的方法应用通知
			
	
	
	
	
	
	
	
	
	
	
	
	
	
	